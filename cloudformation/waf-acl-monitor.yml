AWSTemplateFormatVersion: '2010-09-09'
Description: 'AWS WAF ACL Monitor - Sistema de alertas para cambios en ACLs WAF'

Parameters:
  MonitoringInterval:
    Type: Number
    Description: 'Intervalo de monitoreo en minutos'
    Default: 5
    AllowedValues:
      - 1
      - 5
      - 10
      - 30
      - 60
    ConstraintDescription: 'Debe ser 1, 5, 10, 30 o 60 minutos'
  Region:
    Type: String
    Description: 'Región AWS donde se desplegarán los recursos'
    Default: 'us-east-1'
    AllowedValues:
      - 'us-east-1'
      - 'us-east-2'
      - 'us-west-1'
      - 'us-west-2'
      - 'eu-west-1'
      - 'eu-central-1'
      - 'ap-southeast-1'
      - 'ap-southeast-2'
  LogRetentionDays:
    Type: Number
    Description: 'Días de retención para logs de CloudWatch'
    Default: 30
    MinValue: 1
    MaxValue: 365
    ConstraintDescription: 'Debe estar entre 1 y 365 días'
  DynamoDBTableName:
    Type: String
    Description: 'Nombre de la tabla DynamoDB para historial de cambios de ACLs'
    Default: 'waf-acl-monitor-history'

Mappings:
  PeriodMap:
    "1":
      Value: 60
    "5":
      Value: 300
    "10":
      Value: 600
    "30":
      Value: 1800
    "60":
      Value: 3600

Resources:
  WAFACLAlertsTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub 'waf-acl-alerts-${AWS::StackName}'
      DisplayName: 'WAF ACL Changes Alerts'

  WAFMonitorLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/waf/acl-monitor/${AWS::StackName}'
      RetentionInDays: !Ref LogRetentionDays

  WAFMonitorDynamoDB:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Ref DynamoDBTableName
      AttributeDefinitions:
        - AttributeName: account_id
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: S
      KeySchema:
        - AttributeName: account_id
          KeyType: HASH
        - AttributeName: timestamp
          KeyType: RANGE
      BillingMode: PAY_PER_REQUEST

  WAFMonitorRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: WAFMonitorPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - wafv2:ListWebACLs
                  - wafv2:GetWebACL
                  - sns:Publish
                  - cloudwatch:PutMetricData
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:Query
                Resource: '*'

  WAFMonitorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'waf-acl-monitor-${AWS::StackName}'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt WAFMonitorRole.Arn
      Timeout: 300
      MemorySize: 512
      Environment:
        Variables:
          SNS_TOPIC_ARN: !Ref WAFACLAlertsTopic
          LOG_GROUP_NAME: !Ref WAFMonitorLogGroup
          MONITORING_INTERVAL: !Ref MonitoringInterval
          REGION: !Ref Region
          AWS_STACK_NAME: !Ref AWS::StackName
          DYNAMODB_TABLE: !Ref DynamoDBTableName
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import logging
          from datetime import datetime, timezone

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def get_account_id():
              sts = boto3.client('sts')
              return sts.get_caller_identity()['Account']

          def get_previous_state(dynamodb, table_name, account_id):
              try:
                  resp = dynamodb.query(
                      TableName=table_name,
                      KeyConditionExpression='account_id = :aid',
                      ExpressionAttributeValues={':aid': {'S': account_id}},
                      ScanIndexForward=False,
                      Limit=1
                  )
                  items = resp.get('Items', [])
                  if items:
                      state = json.loads(items[0]['new_state']['S'])
                      # Limpiar el estado anterior también
                      return clean_for_json(state)
                  return None
              except Exception as e:
                  logger.error(f"Error leyendo estado anterior: {e}")
                  return None

          def save_state(dynamodb, table_name, account_id, timestamp, old_state, new_state, change_type, details):
              item = {
                  'account_id': {'S': account_id},
                  'timestamp': {'S': timestamp},
                  'old_state': {'S': json.dumps(old_state) if old_state else ''},
                  'new_state': {'S': json.dumps(new_state)},
                  'change_type': {'S': change_type},
                  'details': {'S': json.dumps(details)}
              }
              dynamodb.put_item(TableName=table_name, Item=item)

          def clean_for_json(obj):
              """Limpia objetos para serialización JSON, convirtiendo bytes a strings"""
              if isinstance(obj, dict):
                  return {k: clean_for_json(v) for k, v in obj.items()}
              elif isinstance(obj, list):
                  return [clean_for_json(item) for item in obj]
              elif isinstance(obj, bytes):
                  return obj.decode('utf-8', errors='ignore')
              elif isinstance(obj, (int, float, str, bool, type(None))):
                  return obj
              else:
                  return str(obj)

          def get_web_acl_details(wafv2, acl_id, acl_name, scope):
              """Obtiene los detalles completos de un ACL usando get_web_acl"""
              try:
                  response = wafv2.get_web_acl(
                      Name=acl_name,
                      Scope=scope,
                      Id=acl_id
                  )
                  # Limpiar la respuesta para JSON
                  return clean_for_json(response['WebACL'])
              except Exception as e:
                  logger.error(f"Error obteniendo detalles del ACL {acl_name}: {e}")
                  return None

          def get_all_web_acls_with_details(wafv2, scope):
              """Obtiene todos los ACLs con sus detalles completos"""
              try:
                  # Primero obtener la lista de ACLs
                  response = wafv2.list_web_acls(Scope=scope)
                  acls = response.get('WebACLs', [])
                  
                  # Obtener detalles completos de cada ACL
                  detailed_acls = []
                  for acl in acls:
                      details = get_web_acl_details(wafv2, acl['Id'], acl['Name'], scope)
                      if details:
                          detailed_acls.append(details)
                      else:
                          # Si no se pueden obtener detalles, usar la información básica
                          detailed_acls.append(acl)
                  
                  return detailed_acls
              except Exception as e:
                  logger.error(f"Error obteniendo ACLs {scope}: {e}")
                  return []

          def describe_acl_changes(old_acls, new_acls):
              """Describe los cambios entre dos conjuntos de ACLs"""
              changes = []
              old_acls_dict = {acl['Name']: acl for acl in old_acls} if old_acls else {}
              new_acls_dict = {acl['Name']: acl for acl in new_acls} if new_acls else {}

              # ACLs agregadas
              for name in new_acls_dict:
                  if name not in old_acls_dict:
                      changes.append(f"ACL agregada: {name}")

              # ACLs eliminadas
              for name in old_acls_dict:
                  if name not in new_acls_dict:
                      changes.append(f"ACL eliminada: {name}")

              # ACLs modificadas
              for name in new_acls_dict:
                  if name in old_acls_dict:
                      acl_changes = []
                      old_acl = old_acls_dict[name]
                      new_acl = new_acls_dict[name]

                      # Comparar reglas
                      old_rules = {r['Name']: r for r in old_acl.get('Rules', [])}
                      new_rules = {r['Name']: r for r in new_acl.get('Rules', [])}

                      # Reglas agregadas
                      for rule_name in new_rules:
                          if rule_name not in old_rules:
                              acl_changes.append(f"  - Regla agregada: {rule_name}")
                              
                      # Reglas eliminadas
                      for rule_name in old_rules:
                          if rule_name not in new_rules:
                              acl_changes.append(f"  - Regla eliminada: {rule_name}")
                              
                      # Reglas modificadas
                      for rule_name in new_rules:
                          if rule_name in old_rules:
                              old_rule = old_rules[rule_name]
                              new_rule = new_rules[rule_name]
                              
                              # Comparar reglas en detalle
                              if old_rule != new_rule:
                                  rule_changes = []
                                  
                                  # Cambios en Statement
                                  if old_rule.get('Statement') != new_rule.get('Statement'):
                                      rule_changes.append("Statement modificado")
                                  
                                  # Cambios en Action
                                  if old_rule.get('Action') != new_rule.get('Action'):
                                      rule_changes.append("Action modificado")
                                  
                                  # Cambios en Priority
                                  if old_rule.get('Priority') != new_rule.get('Priority'):
                                      rule_changes.append(f"Priority cambiado: {old_rule.get('Priority')} -> {new_rule.get('Priority')}")
                                  
                                  # Cambios en RateBasedStatement
                                  old_rate = old_rule.get('Statement', {}).get('RateBasedStatement', {})
                                  new_rate = new_rule.get('Statement', {}).get('RateBasedStatement', {})
                                  if old_rate.get('Limit') != new_rate.get('Limit'):
                                      rule_changes.append(f"Rate limit cambiado: {old_rate.get('Limit')} -> {new_rate.get('Limit')}")
                                  
                                  # Cambios en ManagedRuleGroupStatement
                                  old_managed = old_rule.get('Statement', {}).get('ManagedRuleGroupStatement', {})
                                  new_managed = new_rule.get('Statement', {}).get('ManagedRuleGroupStatement', {})
                                  if old_managed != new_managed:
                                      rule_changes.append("ManagedRuleGroupStatement modificado")
                                  
                                  # Cambios en RuleGroupReferenceStatement
                                  old_ref = old_rule.get('Statement', {}).get('RuleGroupReferenceStatement', {})
                                  new_ref = new_rule.get('Statement', {}).get('RuleGroupReferenceStatement', {})
                                  if old_ref != new_ref:
                                      rule_changes.append("RuleGroupReferenceStatement modificado")
                                  
                                  if rule_changes:
                                      acl_changes.append(f"  - Regla modificada: {rule_name}")
                                      acl_changes.extend([f"    * {change}" for change in rule_changes])

                      # Cambios en DefaultAction
                      if old_acl.get('DefaultAction') != new_acl.get('DefaultAction'):
                          old_action = old_acl.get('DefaultAction', {})
                          new_action = new_acl.get('DefaultAction', {})
                          acl_changes.append(f"  - DefaultAction cambiado: {old_action} -> {new_action}")

                      # Cambios en Description
                      if old_acl.get('Description') != new_acl.get('Description'):
                          acl_changes.append(f"  - Descripción cambiada: {old_acl.get('Description')} -> {new_acl.get('Description')}")

                      # Cambios en VisibilityConfig
                      old_visibility = old_acl.get('VisibilityConfig', {})
                      new_visibility = new_acl.get('VisibilityConfig', {})
                      if old_visibility != new_visibility:
                          acl_changes.append("  - VisibilityConfig modificado")

                      if acl_changes:
                          changes.append(f"ACL modificada: {name}\n" + "\n".join(acl_changes))
              
              return changes

          def compare_states(old, new):
              if not old:
                  return True, 'initial', {'message': 'Primera ejecución'}
              
              changes = []
              # Regional
              changes += describe_acl_changes(old.get('regional_acls', []), new.get('regional_acls', []))
              # Global
              changes += describe_acl_changes(old.get('global_acls', []), new.get('global_acls', []))
              
              if changes:
                  return True, 'changed', {'changes': changes}
              return False, 'no_change', {'message': 'Sin cambios'}

          def lambda_handler(event, context):
              logger.info("INICIO LAMBDA")
              try:
                  region = os.environ.get('REGION', 'us-east-1')
                  sns_topic_arn = os.environ.get('SNS_TOPIC_ARN')
                  table_name = os.environ.get('DYNAMODB_TABLE')

                  wafv2 = boto3.client('wafv2', region_name=region)
                  sns = boto3.client('sns', region_name=region)
                  dynamodb = boto3.client('dynamodb', region_name=region)

                  account_id = get_account_id()
                  timestamp = datetime.now(timezone.utc).isoformat()

                  # Obtener ACLs regionales con detalles completos
                  logger.info("Obteniendo ACLs regionales con detalles...")
                  regional_acls = get_all_web_acls_with_details(wafv2, 'REGIONAL')

                  # Obtener ACLs globales con detalles completos (solo en us-east-1)
                  global_acls = []
                  if region == 'us-east-1':
                      logger.info("Obteniendo ACLs globales con detalles...")
                      global_acls = get_all_web_acls_with_details(wafv2, 'CLOUDFRONT')

                  current_state = {
                      'regional_acls': regional_acls,
                      'global_acls': global_acls,
                      'total_acls': len(regional_acls) + len(global_acls),
                      'timestamp': timestamp
                  }

                  # Leer estado anterior
                  previous_state = get_previous_state(dynamodb, table_name, account_id)
                  
                  # Log resumido para evitar problemas con objetos grandes
                  if previous_state:
                      logger.info(f"Previous state: {len(previous_state.get('regional_acls', []))} regional ACLs, {len(previous_state.get('global_acls', []))} global ACLs")
                  else:
                      logger.info("Previous state: None (primera ejecución)")
                  
                  logger.info(f"Current state: {len(current_state.get('regional_acls', []))} regional ACLs, {len(current_state.get('global_acls', []))} global ACLs")

                  # Comparar estados
                  changed, change_type, details = compare_states(previous_state, current_state)
                  logger.info(f"Resultado comparación: changed={changed}, change_type={change_type}, details={details}")

                  # Guardar historial en DynamoDB
                  save_state(dynamodb, table_name, account_id, timestamp, previous_state, current_state, change_type, details)

                  # Publicar alerta si hay cambios
                  if changed and sns_topic_arn:
                      if change_type == 'initial':
                          message = (
                              f"Primera ejecución de monitoreo de ACLs de WAF.\n"
                              f"Total ACLs: {current_state['total_acls']}\n"
                              f"Timestamp: {timestamp}\n"
                              f"Cuenta: {account_id}\n"
                              f"Región: {region}"
                          )
                      else:
                          message = (
                              f"🚨 Cambio detectado en AWS WAF ACLs\n\n"
                              f"Detalles de los cambios:\n"
                              f"{chr(10).join(details.get('changes', []))}\n\n"
                              f"Total ACLs antes: {len(previous_state.get('regional_acls', [])) + len(previous_state.get('global_acls', [])) if previous_state else 'N/A'}\n"
                              f"Total ACLs ahora: {current_state['total_acls']}\n"
                              f"Timestamp: {timestamp}\n"
                              f"Cuenta: {account_id}\n"
                              f"Región: {region}"
                          )
                      sns.publish(
                          TopicArn=sns_topic_arn,
                          Subject="Alerta de cambio en AWS WAF ACL",
                          Message=message
                      )
                      logger.info("Alerta publicada en SNS.")
                  else:
                      logger.info("Sin cambios detectados o SNS_TOPIC_ARN no configurado.")

                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'changed': changed,
                          'change_type': change_type,
                          'details': details,
                          'current_state': current_state
                      })
                  }
              except Exception as e:
                  logger.error(f"Excepción inesperada: {e}", exc_info=True)
                  raise

  WAFMonitorRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub 'waf-acl-monitor-rule-${AWS::StackName}'
      Description: 'Regla para monitorear cambios en ACLs WAF'
      ScheduleExpression: !Sub 'rate(${MonitoringInterval} minutes)'
      State: ENABLED
      Targets:
        - Arn: !GetAtt WAFMonitorFunction.Arn
          Id: WAFMonitorTarget

  WAFMonitorPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref WAFMonitorFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt WAFMonitorRule.Arn

  WAFACLChangesAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub 'waf-acl-changes-alarm-${AWS::StackName}'
      AlarmDescription: 'Alerta cuando se detectan cambios en ACLs WAF'
      MetricName: WAFACLChanges
      Namespace: AWS/WAF
      Statistic: Sum
      Period: !FindInMap [PeriodMap, !Ref MonitoringInterval, Value]
      EvaluationPeriods: 1
      Threshold: 0
      ComparisonOperator: GreaterThanThreshold
      AlarmActions:
        - !Ref WAFACLAlertsTopic
      Dimensions:
        - Name: Region
          Value: !Ref Region
        - Name: StackName
          Value: !Ref AWS::StackName

Outputs:
  SNSTopicArn:
    Description: 'ARN del SNS Topic para alertas'
    Value: !Ref WAFACLAlertsTopic
  LambdaFunctionArn:
    Description: 'ARN de la función Lambda de monitoreo'
    Value: !GetAtt WAFMonitorFunction.Arn
  CloudWatchLogGroup:
    Description: 'Nombre del grupo de logs de CloudWatch'
    Value: !Ref WAFMonitorLogGroup
  CloudWatchAlarm:
    Description: 'Nombre de la alarma de CloudWatch'
    Value: !Ref WAFACLChangesAlarm 